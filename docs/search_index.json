[["index.html", "Computational Movement Analysis: Patterns and Trends in Environmental Data Master ENR, Spring Semester 2022 Welcome to the course! License", " Computational Movement Analysis: Patterns and Trends in Environmental Data Master ENR, Spring Semester 2022 Patrick Laube, Nils Ratnaweera, Nikolaos Bakogiannis 28 März, 2022 Welcome to the course! For the practical part of the course, building-up skills for analyzing movement data in the software environment R, youll be using data from the ZHAW project Prävention von Wildschweinschäden in der Landwirtschaft. The project investigates the spatiotemporal movement patterns of wild boar (Sus scrofa) in agricultural landscapes. We will study the trajectories of these wild boar, practising the most basic analysis tasks of Computational Movement Analysis (CMA). This video gives a nice introduction into the project License These R Exercises are created by Patrick Laube, Nils Ratnaweera and Nikolaos Bakogiannis for the Course *Computational Movement Analysis\" and are licensed under Creative Commons Attribution 4.0 International License. This work is licensed under a Creative Commons Attribution 4.0 International License. "],["W00_01_preparations.html", "Preparation Check you version of R Check your version of RStudio Install the necessary packages Install Git Configure RStudio Introduce yourself to Git Prepare the folder structure for this course Create an RStudio project for the first week", " Preparation Much of this chapter was taken from Bryan and Heister (2021). If you want to dive deeper into using Git, we highly recommend this book. For an even deeper dive into Git, read Chacon and Straub (2014). Both books are available free and open source on happygitwithr.com and git-scm.com/book, respectively. Check you version of R Check your Version of R by opening RStudio and typing the following command into the console. R.version.string ## [1] &quot;R version 4.1.3 (2022-03-10)&quot; This returns the version number of your R installation, whereas the first digit (4) indicates the number of the major release, the second digit (1) indicates the minor release and the last digit (3) refers to the patch release. As a general rule of thumb, you will want to update R if you dont have the current major version or are lagging two (or more) versions behind the current minor release In the time of writing (März, 2022), the current R Version is 4.1.3 (released on 2022-03-10 08:05:38, see cran.r-project.org). Your installation should therefore not be older than 4.0.0. If it is, make sure that you have updated R until next week (doing it now will probably take too long). Check these instructions on how to update R Check your version of RStudio RStudio is the Graphical User Interface (GUI) we use in our course to interact with R. RStudio should not be too old either and we recommend updating if you dont have the latest version: check if this is the case by clicking on help &gt; check for updates. If you need to update RStudio, dont update now but have a newer version of RStudio installed before next week. Install the necessary packages If you havent already, install the following packages using install.packages(). install.packages(&quot;dplyr&quot;) install.packages(&quot;tidyr&quot;) install.packages(&quot;readr&quot;) install.packages(&quot;ggplot2&quot;) install.packages(&quot;sf&quot;) install.packages(&quot;terra&quot;) Install Git Next, install Git. There are different Git installers to choose from, we recommend the following: Windows: We recommend installing Git for Windows, also known as msysgit or Git Bash. When asked about Adjusting your PATH environment, select Git from the command line and also from 3rd-party software RStudio prefers Git to be installed in C:/Program Files/Git, we recommend following this convention Otherwise, we believe it is good to accept the defaults macOS: We recommend you install the Xcode command line tools (not all of Xcode), which includes Git Go to the shell and enter xcode-select --install to install developer command line tools Linux: On Ubuntu or Debian Linux: sudo apt-get install git On Fedora or RedHat Linux: sudo yum install git Configure RStudio Now we will set some RStudio Global options. But first, close all instances of RStudio and restart it (!!!). Then go to Tools &gt; Global options. R General Deactivate the option Restore .RData into workspace at startup1 Set Save workspace to .RData on exit to Never2 Git / SVN Activate the option Enable version control interface for RStudio projects If the Field Git executable: shows (Not Found), browse to your git installation (previous step). This path should look something like this: Windows: C:/Program Files/Git/bin/git.exe (not C:/Program Files/Git/cmd/git.exe or some-path/git-bash.exe) Linux / macOS: /usr/bin/git Terminal Set option New terminals open with to Git Bash Click on Ok to apply the change and close the options menu. Introduce yourself to Git Now it is time to introduce yourself to git. For this, we need to use the shell terminal, which is why we are going to spend a few word on the shell first. The shell is a program on your computer whose job is to run other programs. It looks very much like the R-console (in the bottom left of RStudio) that you are already know: You have a place to input text which is transferred to (and interpreted by) the computer when you press enter. RStudio has a shell terminal right next to the R-console (tab Terminal). Every Windows comes with two different shell installations: Command prompt and PowerShell. After installing Git we now have a third option, Git Bash. The shell terminal in RStudio uses Command prompt per default, in the last step we just switched the shell to Git Bash. Now use the terminal in RStudio to introduce yourself: git config --global user.name &quot;Maria Nusslinger&quot; git config --global user.email &quot;nussmar@email.com&quot; Of course, replace the name and address with your credentials. Use the email address that you will use to create your Github account (which we will do next week). Prepare the folder structure for this course By this point, you probably have created a folder for this course somewhere on your computer. In our example, we assume this folder is located here: C:/Users/yourname/semester2/Modul_CMA (mentally replace this with your actual path). Before we dive into the exercises, take a minute to think about how you are going to structure your files in this folder. This course will take place over 7 weeks, and in each week you will receive or produce various files. We recommend creating a separate folder for each week, and one folder for the semester project, like so: Course Folder (C:\\\\Users\\\\yourname\\\\semester2\\\\Modul_CMA) ¦--week1 ¦--week2 ¦--week3 ¦--week4 ¦--week5 ¦--week6 ¦--week7 °--semester_project For the R-exercises that take place in weeks 1 to 5, we recommend that you create a new RStudio Project each week in subdirectory of the appropriate week. For example, this week your folder structure could look like this: Folder Week 1 (C:\\\\Users\\\\yourname\\\\semester2\\\\Modul_CMA\\\\week1) ¦--slides.pdf ¦--my_notes.docx ¦--seminar_screenshot.jpg °--week1-rexercise ¦--week1-rexercise.Rproj ¦--wildschwein_BE.csv °--my_solution.Rmd Note: the RStudio Project is located in a subfolder of C:/Users/yourname/semester2/Modul_CMA/week1 and named week1-rexercise. week1-rexercise is the projects directory name and the project name we realize that that the week number is redundant, there is a reason3 for this this means each week is a fresh start (which has pros and cons) Create an RStudio project for the first week Create a new RStudio Project (File &gt; New Project &gt; New Directory &gt; New Project). Click on Browse and switch to your equivalent of the folder C:/Users/yourname/semester2/Modul_CMA/week1 (the project we are about to initiate will be be created in a subdirectory of this folder). Click on open to confirm the selection In the field Directory name, type week1-rexercise. This will be the name of your RStudio project and its parent directory. Check the option Create a git repository Click on Create Project You are all set! You can start working on the tasks of exercise 1. We recommend that you start each RStudio session with a blank slate, as recommended by Wickham and Grolemund (2017) see here If we dont restore the workspace at startup, there is no need to save it on exit. You will see the project names of all your RStudio Projects listed in RStudio. Having the week number in the project name keeps you from getting confused on which project you are working on. "],["W01_01_exercise.html", "Exercise 1", " Exercise 1 This exercise covers the necessary steps for getting ready in R and some basic concepts for setting up a well-structured R project. The lesson introduces how additional packages that provide useful functions for data science are made available and how spatial data is handled. The exercise concludes with the creation of your first map featuring movement data. Learning Outcomes* You learn how to structure an R project. You can read movement data from a .csv-file into a data.frame You can convert spatial point data from a data.frame to a spatial object sf You can perform basic spatial operations on spatial objects in R You can produce simple maps of your spatial data using ggplot2 You can produce simple maps of your spatial data using tmap Prerequisites* Readings Skills from R for Data Science (Wickham and Grolemund 2017): RS1.1 Preface (16p, ix-xxiv) RS1.2 Chap2 Workflow basics (3p, 37-39) RS1.3 Chap4 Workflow scripts (3p, 77-79) RS1.4 Chap6 workflow projects (6p, 111-116) RS1.5 Chap8 Data Import with readr (21p) RS1.6 Chap13 Date and Times with lubridate (18p, 237-256) "],["W01_03_Slides.html", "Slides", " Slides Slides for Nils Input: "],["W01_05_tasks_and_inputs.html", "Tasks and inputs", " Tasks and inputs Before starting with the task: make sure you have read and followed the instructions in section Preparation In RStudio, open the RStudio Project you created for this week if you havent done so already. You can see that you are in an RStudio Project if the projects name is visible next to the little RStudio logo in the top right corner of RStudio (otherwise it will read Project: (None)). Download the wildboar movement data here: wildschwein_BE.csv (right click Save target as..) Once you have set everything up, commit your file to your git repo in the following manner: Save your (R/RMarkdown) file Switch to the Git-Tab in the pane in the top right corner Click commit to open the commit-Window Click in the checkbox next to the file(s) you want to commit Add a commit message to explain what you are committing (e.g. initial commit) Click on commit to commit your changes Task 1: Import data Create a new R- (or RMarkdown) file and begin by loading the following packages: library(readr) # to import tabular data (e.g. csv) library(dplyr) # to manipulate (tabular) data library(ggplot2) # to visualize data Move the file wildschwein_BE.csv into your project directory and import it into r as a data.frame. Assign correct column types as necessary and make sure the time zone is set correctly for the date/time column. Note: We recommend using the readr package to import your data (they all begin with read_*, note the underscore). These functions are less error prone than the base R functions (read.*, note the period). Specifically for the wild boar data, we recommend read_delim(). For everyone working on the RStudio Server: You will first need to upload this data to the server using the upload-button in the Files tab. Commit your changes as described in the beginning. Write a meaningful commit message (e.g. completed task 1). Task 2: Explore Data We will use a range of different visualization tools (i.e. R-packages) in this course. Several packages techniques have emerged in recent years, each with their specific strengths and weaknesses. While base::plot()is quick and simple, it not very scalable with growing complexity. ggplot2 offers solutions for most use cases and has an elegant, consistent syntax that is easy to get accustomed to. We will get to know other techniques later in the course. Get an overview of your data by creating a first map-like plot of your data producing a simple scatter plot with ggplot2. Setting up a ggplot with our data is done using the command ggplot(wildschwein_BE, aes(Long, Lat, colour = TierID)). Creating a map is done via the basic scatter plot command geom_point(). Assigning every individual its own colour is done using the ggplot argument colour =. Commit your changes as described in the beginning. Have a look at your commit history by clicking on History in the Git-Pane. Figure 1: Your plot should look something like this. Input: Handling spatial data Until now, weve stored our location data within data frames as Lat/Long columns. This works well for many tasks, but sometimes we need special spatial classes to handle our trajectories. We will get to know such cases in our next tasks, but first we need to convert our data.frame into a spatial object. We will largely rely on sfwhen working with vector data in R. In order to transform our data.frame into an sf object, we need to use the function st_as_sf() while specifying the columns storing the coordinates and the coordinate reference system. (At this point, we assume you know what a Coordinate Reference Systems is. Check out this link if this is not the case.) library(sf) wildschwein_BE_sf &lt;- st_as_sf(wildschwein_BE, coords = c(&quot;Long&quot;, &quot;Lat&quot;), crs = 4326) Notice how st_as_sf takes the EPSG code for the crs = argument. You can find a lot of useful information on Coordinate Reference Systems (including EPSG Codes, etc.) under epsg.io. Lets compare our original data.frame with this new sf object: wildschwein_BE ## # A tibble: 51,246 x 6 ## TierID TierName CollarID DatetimeUTC Lat Long ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 002A Sabi 12275 2014-08-22 21:00:12 47.0 7.05 ## 2 002A Sabi 12275 2014-08-22 21:15:16 47.0 7.05 ## 3 002A Sabi 12275 2014-08-22 21:30:43 47.0 7.05 ## 4 002A Sabi 12275 2014-08-22 21:46:07 47.0 7.05 ## 5 002A Sabi 12275 2014-08-22 22:00:22 47.0 7.05 ## 6 002A Sabi 12275 2014-08-22 22:15:10 47.0 7.05 ## 7 002A Sabi 12275 2014-08-22 22:30:13 47.0 7.05 ## 8 002A Sabi 12275 2014-08-22 22:45:11 47.0 7.05 ## 9 002A Sabi 12275 2014-08-22 23:00:27 47.0 7.05 ## 10 002A Sabi 12275 2014-08-22 23:15:41 47.0 7.05 ## # ... with 51,236 more rows wildschwein_BE_sf ## Simple feature collection with 51246 features and 4 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: 7.019889 ymin: 46.97125 xmax: 7.112075 ymax: 47.01882 ## Geodetic CRS: WGS 84 ## # A tibble: 51,246 x 5 ## TierID TierName CollarID DatetimeUTC geometry ## * &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dttm&gt; &lt;POINT [°]&gt; ## 1 002A Sabi 12275 2014-08-22 21:00:12 (7.049618 46.99317) ## 2 002A Sabi 12275 2014-08-22 21:15:16 (7.049509 46.99416) ## 3 002A Sabi 12275 2014-08-22 21:30:43 (7.049406 46.99383) ## 4 002A Sabi 12275 2014-08-22 21:46:07 (7.049217 46.99375) ## 5 002A Sabi 12275 2014-08-22 22:00:22 (7.049359 46.99375) ## 6 002A Sabi 12275 2014-08-22 22:15:10 (7.049363 46.99382) ## 7 002A Sabi 12275 2014-08-22 22:30:13 (7.049326 46.99387) ## 8 002A Sabi 12275 2014-08-22 22:45:11 (7.049237 46.99395) ## 9 002A Sabi 12275 2014-08-22 23:00:27 (7.048383 46.99481) ## 10 002A Sabi 12275 2014-08-22 23:15:41 (7.049396 46.99373) ## # ... with 51,236 more rows As you can see, st_as_sf() has added some metadata to our dataframe (geometry type, dimension, bbox, epsg and proj4string) and replaced the columns Lat and Long with a column named geometry. Other than that, the new sf object is very similar to our original dataframe. In fact, sf objects are essentially dataframes, as you can verify with the function is.data.frame(): is.data.frame(wildschwein_BE_sf) ## [1] TRUE All operations we know from handling data.frames can be used on the sf object. Try some out! # subset rows wildschwein_BE_sf[1:10,] wildschwein_BE_sf[wildschwein_BE_sf$TierName == &quot;Sabi&quot;,] # subset colums wildschwein_BE_sf[,2:3] Instead of keeping the same data twice (once as a data.frame, and once as an sf object), we will overwrite the data.frame and continue working with the sf object from now on. This saves some memory space in R and avoids confusion. wildschwein_BE &lt;- st_as_sf(wildschwein_BE, coords = c(&quot;Long&quot;, &quot;Lat&quot;), crs = 4326) rm(wildschwein_BE_sf) # we can remove this sf object, since it just eats up our memory Task 3: Project data from WGS84 So what can we do with our new sf object that we couldnt before? One example is projecting the WGS84 (Lat/Long) coordinates into the new Swiss CRS CH1903+ LV954. Do this by using the function st_transform. By the way, do you notice a pattern here? The package sf names most functions for spatial operations with the prefix st_*, just as in PostGIS. Heres the resulting sf object from the operation: wildschwein_BE ## Simple feature collection with 51246 features and 4 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: 2568153 ymin: 1202306 xmax: 2575154 ymax: 1207609 ## Projected CRS: CH1903+ / LV95 ## # A tibble: 51,246 x 5 ## TierID TierName CollarID DatetimeUTC geometry ## * &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dttm&gt; &lt;POINT [m]&gt; ## 1 002A Sabi 12275 2014-08-22 21:00:12 (2570409 1204752) ## 2 002A Sabi 12275 2014-08-22 21:15:16 (2570402 1204863) ## 3 002A Sabi 12275 2014-08-22 21:30:43 (2570394 1204826) ## 4 002A Sabi 12275 2014-08-22 21:46:07 (2570379 1204817) ## 5 002A Sabi 12275 2014-08-22 22:00:22 (2570390 1204818) ## 6 002A Sabi 12275 2014-08-22 22:15:10 (2570390 1204825) ## 7 002A Sabi 12275 2014-08-22 22:30:13 (2570387 1204831) ## 8 002A Sabi 12275 2014-08-22 22:45:11 (2570381 1204840) ## 9 002A Sabi 12275 2014-08-22 23:00:27 (2570316 1204935) ## 10 002A Sabi 12275 2014-08-22 23:15:41 (2570393 1204815) ## # ... with 51,236 more rows Commit your changes as described in the beginning. Input: Calculate Convex Hull Transforming from one Coordinate Reference System to another was one operation where we needed an object with a spatial nature. In this way, we were able to use an off the shelf function to project the coordinates from one CRS to another. In our next example, we again rely on a spatial function: We want to calculate a convex hull per Wild boar. And guess what the function for calculating a convex hull is called in sf? If you guessed st_convex_hull(), you were right! By default st_convex_hull() calculates the convex hull per feature, i.e. per point in our dataset. This of course makes little sense. In order to calculate the convex hull per animal, we need to convert our point- to multipoint-features where each feature contains all positions of one animal. This is achieved in two steps: First: add a grouping variable to the sf object. Note the new grouping variable in the metadata of the sf object. Other than that, group_by has no effect on our sf object. wildschwein_BE_grouped &lt;- group_by(wildschwein_BE,TierID) wildschwein_BE_grouped ## Simple feature collection with 51246 features and 4 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: 2568153 ymin: 1202306 xmax: 2575154 ymax: 1207609 ## Projected CRS: CH1903+ / LV95 ## # A tibble: 51,246 x 5 ## # Groups: TierID [3] ## TierID TierName CollarID DatetimeUTC geometry ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dttm&gt; &lt;POINT [m]&gt; ## 1 002A Sabi 12275 2014-08-22 21:00:12 (2570409 1204752) ## 2 002A Sabi 12275 2014-08-22 21:15:16 (2570402 1204863) ## 3 002A Sabi 12275 2014-08-22 21:30:43 (2570394 1204826) ## 4 002A Sabi 12275 2014-08-22 21:46:07 (2570379 1204817) ## 5 002A Sabi 12275 2014-08-22 22:00:22 (2570390 1204818) ## 6 002A Sabi 12275 2014-08-22 22:15:10 (2570390 1204825) ## 7 002A Sabi 12275 2014-08-22 22:30:13 (2570387 1204831) ## 8 002A Sabi 12275 2014-08-22 22:45:11 (2570381 1204840) ## 9 002A Sabi 12275 2014-08-22 23:00:27 (2570316 1204935) ## 10 002A Sabi 12275 2014-08-22 23:15:41 (2570393 1204815) ## # ... with 51,236 more rows Second: use summarise() to dissolve all points into a mulipoint object. wildschwein_BE_smry &lt;- summarise(wildschwein_BE_grouped) wildschwein_BE_smry ## Simple feature collection with 3 features and 1 field ## Geometry type: MULTIPOINT ## Dimension: XY ## Bounding box: xmin: 2568153 ymin: 1202306 xmax: 2575154 ymax: 1207609 ## Projected CRS: CH1903+ / LV95 ## # A tibble: 3 x 2 ## TierID geometry ## &lt;chr&gt; &lt;MULTIPOINT [m]&gt; ## 1 002A ((2568903 1206200), (2568925 1206207), (2568980 1206197), (2569024 120~ ## 2 016A ((2569231 1205823), (2569245 1205925), (2569247 1206027), (2569251 120~ ## 3 018A ((2568153 1205611), (2568155 1205613), (2568161 1205624), (2568162 120~ Now we can run st_convex_hull on the new sf object. mcp &lt;- st_convex_hull(wildschwein_BE_smry) Task 4: Ploting spatial objects Using base plot to visualize sf objects is easy enough, just try the following code. plot(mcp) But since we use ggplot extensively, try and plot the object mcp with ggplot. Hint: Use the layer geom_sf() to add an sf object. Note: ggplot refuses to use our specified CRS, so we need to force this by specifying datum = in coord_sf(). Try it out. Commit your changes as described in the beginning. Have a look at your commit history by clicking on History in the Git-Pane. Input: Importing raster data In the next task, we would like to add a background map to our mcp object. Download the file here: pk100_BE.tif To import the file into R, we use the package terra with the function rast. library(terra) pk100_BE &lt;- terra::rast(&quot;00_Rawdata/pk100_BE.tif&quot;) pk100_BE ## class : SpatRaster ## dimensions : 1821, 2321, 3 (nrow, ncol, nlyr) ## resolution : 5, 5 (x, y) ## extent : 2567000, 2578605, 1199996, 1209101 (xmin, xmax, ymin, ymax) ## coord. ref. : CH1903+ / LV95 (EPSG:2056) ## source : pk100_BE.tif ## names : pk1_1, pk1_2, pk1_3 ## min values : 0, 0, 0 ## max values : 255, 255, 255 pk100_BE_2056.tif is a three layered geotiff File. The above console output shows some metadata including the resolution, extent and the names of our layers (pk1_1, pk1_2etc). With the default plot method, each layer is displayed individually: plot(pk100_BE) With plotRGB all three layers are combined into a single image: plotRGB(pk100_BE) Task 5: Adding a background map There are multiple ways to add a background map in ggplot, many require additional packages. This is a good opportunity to get to know a completely different package for creating maps: tmap (thematic map). This package was developed with a syntax very similar to ggplot2, which makes it easy to learn. library(tmap) tm_shape(pk100_BE) + tm_rgb() As you can see, plotting layers in tmap is combined with the + sign, just as in ggplot2. In tmap however, each layer consists of two objects: a tm_shape() in which the data is called, and a tm_* object in which we define how the data is visualized (tm_rgb() states that it is plotted as an RGB Raster Layer). Add the object mcp to the plot in this manner. Read the vignette if you are having trouble. Commit your changes as described in the beginning. Task 6: Create an interactive map Rerun the tmap()... command from the previous task, but switch the plotting mode to view\" (tmap_mode(\"view\")) beforehand. Omit the raster layer (pk100_BE), you wont be needing it. Commit your changes as described in the beginning. Have a look at your commit history by clicking on History in the Git-Pane. As weve mentioned in the first Input, you can look up the EPSG codes under (epsg.io)[http://epsg.io]. For information specific to Switzerland, check the swisstopo website "],["W01_06_solutions.html", "Solutions", " Solutions Hover over the code and copy the content by clicking on the clipboard icon on the top right. You can now paste this into an R-Script. # task 1 ######################################################################## # Data import #### wildschwein_BE &lt;- read_delim(&quot;00_Rawdata/wildschwein_BE.csv&quot;,&quot;,&quot;) # Check Timezone attr(wildschwein_BE$DatetimeUTC,&quot;tzone&quot;) # or wildschwein_BE$DatetimeUTC[1] # task 2 ######################################################################## ggplot(wildschwein_BE, aes(Long,Lat, colour = TierID)) + geom_point() + coord_map() + theme(legend.position = &quot;none&quot;) # task 3 ######################################################################## wildschwein_BE &lt;- st_transform(wildschwein_BE, 2056) # task 4 ######################################################################## ggplot(mcp,aes(fill = TierID)) + geom_sf(alpha = 0.4) ggplot(mcp,aes(fill = TierID)) + geom_sf(alpha = 0.4) + coord_sf(datum = 2056) # task 5 ######################################################################## library(tmap) tm_shape(pk100_BE) + tm_rgb() tm_shape(pk100_BE) + tm_rgb() + tm_shape(mcp) + tm_polygons(col = &quot;TierID&quot;,alpha = 0.4,border.col = &quot;red&quot;) + tm_legend(bg.color = &quot;white&quot;) # task 6 ######################################################################## tmap_mode(&quot;view&quot;) tm_shape(mcp) + tm_polygons(col = &quot;TierID&quot;,alpha = 0.4,border.col = &quot;red&quot;) + tm_legend(bg.color = &quot;white&quot;) "],["W02_01_exercise.html", "Exercise 2", " Exercise 2 Learning Outcomes* You understand the dplyr functions mutate, summarise and group_by and can apply them to sf objects You can derive movement parameters (timelag, steplength, speed) from trajectory data. You can re-sample your trajectory data for cross-scale movement analysis. Prerequisites* Readings Skills from R for Data Science (Wickham and Grolemund 2017): RS2.1 Chap3 Data Transformation with dplyr (31p, 43-76) RS2.2 Chap10 Relational data with dplyr (21p, 171-193) RS2.3 Chap14 Pipes with magrittr (6p, 261-268) Readings Theory R2.1 Laube and Purves (2011): How fast is a cow? cross - scale analysis of movement data. "],["W02_04_demo_tidyverse.html", "Demo Tidyverse", " Demo Tidyverse Depending on your knowledge of R, getting an overview of the data we imported last week might have been quite a challenge. Surprisingly enough, importing, cleaning and exploring your data can be the most challenging, time consuming part of a project. RStudio and the tidyverse offer many helpful tools to make this part easier (and more fun). You have read chapters on dplyr and magrittr as a preparation for this exercise. Before we start with the exercise however, this demo illustrates a simple approach offered by tidyverse which is applicable to sf-objects. Assume we want to calculate the timelag between subsequent positions. To achieve this we can use the function difftime() combined with lead() from dplyr. Lets look at these functions one by one. difftime difftime takes two POSIXct values. now &lt;- Sys.time() later &lt;- now + 10000 time_difference &lt;- difftime(later,now) time_difference ## Time difference of 2.777778 hours You can also specify the unit of the output. time_difference &lt;- difftime(later,now,units = &quot;mins&quot;) time_difference ## Time difference of 166.6667 mins difftime returns an object of the Class difftime. However in our case, numeric values would be more handy than the Class difftime. So well wrap the command in as.numeric(): str(time_difference) ## &#39;difftime&#39; num 166.666666666667 ## - attr(*, &quot;units&quot;)= chr &quot;mins&quot; time_difference &lt;- as.numeric(difftime(later,now,units = &quot;mins&quot;)) str(time_difference) ## num 167 lead() / lag() lead() and lag() return a vector of the same length as the input, just offset by a specific number of values (default is 1). Consider the following sequence: numbers &lt;- 1:10 numbers ## [1] 1 2 3 4 5 6 7 8 9 10 We can now run lead() and lag() on this sequence to illustrate the output. n = specifies the offset, default = specifies the default value used to fill the emerging empty spaces of the vector. This helps us performing operations on subsequent values in a vector (or rows in a table). library(dplyr) ## ## Attache Paket: &#39;dplyr&#39; ## Die folgenden Objekte sind maskiert von &#39;package:stats&#39;: ## ## filter, lag ## Die folgenden Objekte sind maskiert von &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union lead(numbers) ## [1] 2 3 4 5 6 7 8 9 10 NA lead(numbers,n = 2) ## [1] 3 4 5 6 7 8 9 10 NA NA lag(numbers) ## [1] NA 1 2 3 4 5 6 7 8 9 lag(numbers,n = 5) ## [1] NA NA NA NA NA 1 2 3 4 5 lag(numbers,n = 5, default = 0) ## [1] 0 0 0 0 0 1 2 3 4 5 mutate() Using the above functions (difftime() and lead()), we can calculate the time lag, that is, the time difference between consecutive positions. We will try this on a dummy version of our wildboar dataset. wildschwein &lt;- tibble( TierID = c(rep(&quot;Hans&quot;,5),rep(&quot;Klara&quot;,5)), DatetimeUTC = rep(as.POSIXct(&quot;2015-01-01 00:00:00&quot;,tz = &quot;UTC&quot;)+0:4*15*60, 2) ) wildschwein ## # A tibble: 10 x 2 ## TierID DatetimeUTC ## &lt;chr&gt; &lt;dttm&gt; ## 1 Hans 2015-01-01 00:00:00 ## 2 Hans 2015-01-01 00:15:00 ## 3 Hans 2015-01-01 00:30:00 ## 4 Hans 2015-01-01 00:45:00 ## 5 Hans 2015-01-01 01:00:00 ## 6 Klara 2015-01-01 00:00:00 ## 7 Klara 2015-01-01 00:15:00 ## 8 Klara 2015-01-01 00:30:00 ## 9 Klara 2015-01-01 00:45:00 ## 10 Klara 2015-01-01 01:00:00 To calculate the timelag with base-R, we need to mention wildschwein three times wildschwein$timelag &lt;- as.numeric(difftime(lead(wildschwein$DatetimeUTC), wildschwein$DatetimeUTC)) Using mutate() we can simplify this operation slightly: wildschwein &lt;- mutate(wildschwein,timelag = as.numeric(difftime(lead(DatetimeUTC),DatetimeUTC))) wildschwein ## # A tibble: 10 x 3 ## TierID DatetimeUTC timelag ## &lt;chr&gt; &lt;dttm&gt; &lt;dbl&gt; ## 1 Hans 2015-01-01 00:00:00 15 ## 2 Hans 2015-01-01 00:15:00 15 ## 3 Hans 2015-01-01 00:30:00 15 ## 4 Hans 2015-01-01 00:45:00 15 ## 5 Hans 2015-01-01 01:00:00 -60 ## 6 Klara 2015-01-01 00:00:00 15 ## 7 Klara 2015-01-01 00:15:00 15 ## 8 Klara 2015-01-01 00:30:00 15 ## 9 Klara 2015-01-01 00:45:00 15 ## 10 Klara 2015-01-01 01:00:00 NA group_by() You might have noticed that timelag is calculated across different individuals (Hans and Klara), which does not make much sense. To avoid this, we need to specify that timelag should just be calculated between consecutive rows of the same individual. We can implement this by using group_by(). wildschwein &lt;- group_by(wildschwein,TierID) After adding this grouping variable, calculating the timelag automatically accounts for the individual trajectories. wildschwein &lt;- mutate(wildschwein,timelag = as.numeric(difftime(lead(DatetimeUTC),DatetimeUTC))) wildschwein ## # A tibble: 10 x 3 ## # Groups: TierID [2] ## TierID DatetimeUTC timelag ## &lt;chr&gt; &lt;dttm&gt; &lt;dbl&gt; ## 1 Hans 2015-01-01 00:00:00 15 ## 2 Hans 2015-01-01 00:15:00 15 ## 3 Hans 2015-01-01 00:30:00 15 ## 4 Hans 2015-01-01 00:45:00 15 ## 5 Hans 2015-01-01 01:00:00 NA ## 6 Klara 2015-01-01 00:00:00 15 ## 7 Klara 2015-01-01 00:15:00 15 ## 8 Klara 2015-01-01 00:30:00 15 ## 9 Klara 2015-01-01 00:45:00 15 ## 10 Klara 2015-01-01 01:00:00 NA summarise() If we want to summarise our data and get metrics per animal, we can use the dplyr function summarise(). In contrast to mutate(), which just adds a new column to the dataset, summarise() collapses the data to one row per individual (specified by group_by). summarise(wildschwein, mean = mean(timelag, na.rm = T)) ## # A tibble: 2 x 2 ## TierID mean ## &lt;chr&gt; &lt;dbl&gt; ## 1 Hans 15 ## 2 Klara 15 Note: You can do mutate() and summarise() on sf objects as well. However, summarise() tries to coerce all geometries into one object, which can take along time. To avoid this, use st_drop_geometry() before using summarise(). Piping The code above may be a bit hard to read, since it has so many nested functions which need to be read from the inside out. In order to make code readable in a more human-friendly way, we can use the piping command %&gt;% from magrittr, which is included in dplyr and the tidyverse. The above code then looks like this: wildschwein %&gt;% # Take wildschwein... group_by(TierID) %&gt;% # ...group it by TierID summarise( # Summarise the data... mean_timelag = mean(timelag,na.rm = T)# ...by calculating the mean timelag ) ## # A tibble: 2 x 2 ## TierID mean_timelag ## &lt;chr&gt; &lt;dbl&gt; ## 1 Hans 15 ## 2 Klara 15 Bring it all together Here is the same approach with a different dataset: pigs &lt;- tibble( TierID = c(8001,8003,8004,8005,8800,8820,3000,3001,3002,3003,8330,7222), sex = c(&quot;M&quot;,&quot;M&quot;,&quot;M&quot;,&quot;F&quot;,&quot;M&quot;,&quot;M&quot;,&quot;F&quot;,&quot;F&quot;,&quot;M&quot;,&quot;F&quot;,&quot;M&quot;,&quot;F&quot;), age= c (&quot;A&quot;,&quot;A&quot;,&quot;J&quot;,&quot;A&quot;,&quot;J&quot;,&quot;J&quot;,&quot;J&quot;,&quot;A&quot;,&quot;J&quot;,&quot;J&quot;,&quot;A&quot;,&quot;A&quot;), weight = c(50.755,43.409,12.000,16.787,20.987,25.765,22.0122,21.343,12.532,54.32,11.027,88.08) ) pigs ## # A tibble: 12 x 4 ## TierID sex age weight ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 8001 M A 50.8 ## 2 8003 M A 43.4 ## 3 8004 M J 12 ## 4 8005 F A 16.8 ## 5 8800 M J 21.0 ## 6 8820 M J 25.8 ## 7 3000 F J 22.0 ## 8 3001 F A 21.3 ## 9 3002 M J 12.5 ## 10 3003 F J 54.3 ## 11 8330 M A 11.0 ## 12 7222 F A 88.1 pigs %&gt;% summarise( mean_weight = mean(weight) ) ## # A tibble: 1 x 1 ## mean_weight ## &lt;dbl&gt; ## 1 31.6 pigs %&gt;% group_by(sex) %&gt;% summarise( mean_weight = mean(weight) ) ## # A tibble: 2 x 2 ## sex mean_weight ## &lt;chr&gt; &lt;dbl&gt; ## 1 F 40.5 ## 2 M 25.2 pigs %&gt;% group_by(sex,age) %&gt;% summarise( mean_weight = mean(weight) ) ## `summarise()` has grouped output by &#39;sex&#39;. You can override using the `.groups` argument. ## # A tibble: 4 x 3 ## # Groups: sex [2] ## sex age mean_weight ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 F A 42.1 ## 2 F J 38.2 ## 3 M A 35.1 ## 4 M J 17.8 "],["W02_04b_demo_tidyverse_code.html", "Demo Tidyverse (R-Code)", " Demo Tidyverse (R-Code) now &lt;- Sys.time() later &lt;- now + 10000 time_difference &lt;- difftime(later,now) time_difference time_difference &lt;- difftime(later,now,units = &quot;mins&quot;) time_difference str(time_difference) time_difference &lt;- as.numeric(difftime(later,now,units = &quot;mins&quot;)) str(time_difference) numbers &lt;- 1:10 numbers library(dplyr) lead(numbers) lead(numbers,n = 2) lag(numbers) lag(numbers,n = 5) lag(numbers,n = 5, default = 0) wildschwein &lt;- tibble( TierID = c(rep(&quot;Hans&quot;,5),rep(&quot;Klara&quot;,5)), DatetimeUTC = rep(as.POSIXct(&quot;2015-01-01 00:00:00&quot;,tz = &quot;UTC&quot;)+0:4*15*60, 2) ) wildschwein wildschwein$timelag &lt;- as.numeric(difftime(lead(wildschwein$DatetimeUTC), wildschwein$DatetimeUTC)) wildschwein &lt;- mutate(wildschwein,timelag = as.numeric(difftime(lead(DatetimeUTC),DatetimeUTC))) wildschwein wildschwein &lt;- group_by(wildschwein,TierID) wildschwein &lt;- mutate(wildschwein,timelag = as.numeric(difftime(lead(DatetimeUTC),DatetimeUTC))) wildschwein summarise(wildschwein, mean = mean(timelag, na.rm = T)) wildschwein %&gt;% # Take wildschwein... group_by(TierID) %&gt;% # ...group it by TierID summarise( # Summarise the data... mean_timelag = mean(timelag,na.rm = T)# ...by calculating the mean timelag ) pigs &lt;- tibble( TierID = c(8001,8003,8004,8005,8800,8820,3000,3001,3002,3003,8330,7222), sex = c(&quot;M&quot;,&quot;M&quot;,&quot;M&quot;,&quot;F&quot;,&quot;M&quot;,&quot;M&quot;,&quot;F&quot;,&quot;F&quot;,&quot;M&quot;,&quot;F&quot;,&quot;M&quot;,&quot;F&quot;), age= c (&quot;A&quot;,&quot;A&quot;,&quot;J&quot;,&quot;A&quot;,&quot;J&quot;,&quot;J&quot;,&quot;J&quot;,&quot;A&quot;,&quot;J&quot;,&quot;J&quot;,&quot;A&quot;,&quot;A&quot;), weight = c(50.755,43.409,12.000,16.787,20.987,25.765,22.0122,21.343,12.532,54.32,11.027,88.08) ) pigs pigs %&gt;% summarise( mean_weight = mean(weight) ) pigs %&gt;% group_by(sex) %&gt;% summarise( mean_weight = mean(weight) ) pigs %&gt;% group_by(sex,age) %&gt;% summarise( mean_weight = mean(weight) ) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
